# Startkit Patterns - ShopChat.vn Backend

## üèóÔ∏è **Module Structure**

### **API Layer (`modules/api/`)**
```typescript
// ‚úÖ ƒê√öNG - Controller trong api/controllers
@Controller('shops')
@ApiTags('Shop Management')
export class ShopController {
  constructor(private readonly shopService: ShopService) {}
  
  @Get()
  @ApiOperation({ summary: 'L·∫•y danh s√°ch c·ª≠a h√†ng' })
  async getShops() {
    return this.shopService.findAll();
  }
}
```

### **Business Layer (`modules/business/services/`)**
```typescript
// ‚úÖ ƒê√öNG - Service trong business/services
@Injectable()
export class ShopService {
  constructor(
    private readonly shopRepository: ShopRepository,
    private readonly openAIService: OpenAIService
  ) {}
  
  async findAll(): Promise<Shop[]> {
    return this.shopRepository.find();
  }
}
```

### **Database Layer (`modules/database/`)**
```typescript
// ‚úÖ ƒê√öNG - Repository trong database/repositories
@Injectable()
export class ShopRepository extends Repository<ShopEntity> {
  async findByLocation(lat: number, lng: number, radius: number = 10) {
    return this.createQueryBuilder('shop')
      .where('ST_DWithin(shop.location, ST_Point(:lng, :lat), :radius)',
        { lng, lat, radius })
      .getMany();
  }
}
```

### **Worker Layer (`modules/worker/`)**
```typescript
// ‚úÖ ƒê√öNG - Consumer trong worker/consumers
@Processor('chatbot')
export class ChatbotConsumer {
  @Process('process-message')
  async processMessage(job: Job<ProcessMessageDto>) {
    // Background job processing
  }
}
```

## üîÑ **Conditional Module Loading**

```typescript
// ‚úÖ ƒê√öNG - Conditional module loading
const isApi = Boolean(Number(process.env.IS_API || 0));
const isWorker = Boolean(Number(process.env.IS_WORKER || 0));

@Module({
  imports: [
    // Conditional modules
    ...(isApi ? [ApiModule] : []),
    ...(isWorker ? [WorkerModule] : []),
    // Shared modules
    BusinessModule,
    DatabaseModule,
    QueueModule,
  ]
})
export class AppModule {}
```

## üìù **Swagger Documentation**

```typescript
// ‚úÖ ƒê√öNG - Complete Swagger documentation
@Controller('shops')
@ApiTags('Shop Management')
export class ShopController {
  
  @Post()
  @ApiOperation({
    summary: 'T·∫°o c·ª≠a h√†ng m·ªõi',
    description: 'T·∫°o m·ªôt c·ª≠a h√†ng m·ªõi v·ªõi th√¥ng tin c∆° b·∫£n'
  })
  @ApiBody({ type: CreateShopDto })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'C·ª≠a h√†ng ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng',
    type: StandardResponseDto<ShopResponseDto>
  })
  async createShop(@Body() createShopDto: CreateShopDto) {
    return this.shopService.create(createShopDto);
  }
}
```

## üîê **RBAC Integration**

```typescript
// ‚úÖ ƒê√öNG - S·ª≠ d·ª•ng RBAC system
@UseGuards(JwtAuthGuard, PermissionGuard)
@RequirePermissions('shop:read', 'own_shops')
@Get('my-shops')
async getMyShops(@CurrentUser() user: User) {
  return this.shopService.findByOwner(user.id);
}
```

## üìä **Structured Logging**

```typescript
// ‚úÖ ƒê√öNG - Structured logging v·ªõi Pino
@Injectable()
export class ShopService {
  private readonly logger = new Logger(ShopService.name);

  async createShop(createShopDto: CreateShopDto): Promise<Shop> {
    this.logger.log(`[‚úÖ] [ShopService] [createShop] [dto]:`, createShopDto);
    
    try {
      const shop = await this.shopRepository.save(createShopDto);
      this.logger.log(`[‚úÖ] [ShopService] [createShop] [result]:`, shop);
      return shop;
    } catch (error) {
      this.logger.error(`[üî¥] [ShopService] [createShop] [error]:`, error);
      throw error;
    }
  }
}
```

## üîÑ **Standard Response Format**

```typescript
// ‚úÖ ƒê√öNG - S·ª≠ d·ª•ng standard response format
@Get()
async getShops(): Promise<StandardResponseDto<ShopResponseDto[]>> {
  const shops = await this.shopService.findAll();
  
  return {
    statusCode: HttpStatus.OK,
    message: 'L·∫•y danh s√°ch c·ª≠a h√†ng th√†nh c√¥ng',
    data: shops,
    timestamp: new Date().toISOString()
  };
}
```

## üß™ **Testing Patterns**

```typescript
// ‚úÖ ƒê√öNG - Test theo startkit patterns
describe('ShopService', () => {
  let service: ShopService;
  let repository: ShopRepository;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        ShopService,
        {
          provide: ShopRepository,
          useValue: {
            find: jest.fn(),
            save: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<ShopService>(ShopService);
    repository = module.get<ShopRepository>(ShopRepository);
  });

  it('should return shops list', async () => {
    const mockShops = [/* mock data */];
    jest.spyOn(repository, 'find').mockResolvedValue(mockShops);

    const result = await service.findAll();
    expect(result).toEqual(mockShops);
  });
});
```

## üéØ **Best Practices**

### **1. Dependency Injection**
- Lu√¥n s·ª≠ d·ª•ng constructor injection
- Kh√¥ng s·ª≠ d·ª•ng `new` keyword trong services
- S·ª≠ d·ª•ng interfaces cho loose coupling

### **2. Type Safety**
- Lu√¥n ƒë·ªãnh nghƒ©a types/interfaces
- S·ª≠ d·ª•ng strict TypeScript config
- Tr√°nh s·ª≠ d·ª•ng `any` type

### **3. Performance**
- S·ª≠ d·ª•ng caching cho expensive operations
- Implement pagination cho large datasets
- Optimize database queries v·ªõi indexes

### **4. Security**
- Validate t·∫•t c·∫£ input data
- S·ª≠ d·ª•ng RBAC cho authorization
- Sanitize user inputs
- Implement rate limiting
